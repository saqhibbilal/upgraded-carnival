sde-hire/
├── .next/
│   ├── cache/
│   │             
│   ├── server/             
│   ├── static/                  
│   ├── types/               
│   └── ...                   # Other files
├── app/
│   ├── api/
│   │   └── /route.js         # This file is a Next.js API route that executes user-submitted code and tests it against multiple inputs using the Judge0 API.
│   ├── dashboard/             # includes component folder and page.tsx file (for the main dashboard)
│   │   └── components/
│   |   │   └── feature-card.tsx
│   |   │   └── features-section.tsx
│   |   │   └── stats-card.tsx
│   |   │   └── stats-section.tsx
│   │   └── page.tsx
│   ├── dsa-tutor/             # includes component folder and page.tsx file(i am showing the whole folder structure because important)
│   │   └── components/
│   |   │   └── ai-assistance.tsx
│   |   │   └── challenge-description.tsx
│   |   │   └── code-actions.tsx
│   |   │   └── code-assistance.tsx
│   |   │   └── code-editor-section.tsx
│   |   │   └── output-section.tsx
│   |   │   └── problem-assistance.tsx
│   |   │   └── problem-header.tsx
│   │   └── dsa-tutor.css
│   │   └── languages.ts
│   │   └── page.tsx
│   │   └── questions.json     # Static DSA problem data
│   │   └── types.ts           # Types for Question, ProblemAssistance, ExecutionResult
│   ├── login/                 # includes component folder and page.tsx file
│   ├── problems/              # includes component folder and page.tsx file
│   │   └── components/
│   |   │   └── problem-card.tsx
│   |   │   └── problem-filters.tsx
│   |   │   └── problem-header.tsx
│   |   │   └── problem-list.tsx
│   │   └── page.tsx
│   ├── profile/               # includes component folder and page.tsx file
│   │   └── components/
│   |   │   └── activity-tab.tsx
│   |   │   └── badges-tab.tsx
│   |   │   └── profile-sidebar.tsx
│   |   │   └── progress-tab.tsx
│   │   └── page.tsx
│   ├── register/               # includes component folder and page.tsx file
│   │   └── components/
│   |   │   └── register-guard.tsx
│   |   │   └── registration-form.tsx
│   │   └── page.tsx
│   ├── signup/                # includes component folder and page.tsx file
│   │   └── components/
│   |   │   └── back-button.tsx
│   |   │   └── signup-form.tsx
│   │   └── page.tsx
│   ├── login/                 # includes component folder and page.tsx file
│   │   └── components/
│   |   │   └── back-button.tsx
│   |   │   └── login-form.tsx
│   │   └── page.tsx
│   └── global.css             #css file
│   └── layout.tsx            #root layout file
│   └── page.tsx              #page file
├── backend/
│   └── app/                  #includes some files not that important              
│   └── explantation-server.js        #includes code for explanation server code which sends SSE to frontend components in dsa-tutor   
│   └── gen-code-server.js            #includes code for explanation server code which sends SSE to frontend components in dsa-tutor 
│   └── problem-assistance-server.js   #includes code for explanation server code which sends SSE to frontend components in dsa-tutor   
│   └── README.md
│   └── package.json
├── components/
│   └── layout /     
│   │   └── auth-layout.tsx    #this is used in almost all components as a wrapper(but the user can signin or login with any email and password as of now)
|   |
│   └── ui/          #these are ui components like accordian and stuff
|   |
│   └── theme-provider.tsx
│   └── theme-toggle.tsx
├── hooks/
│   └── use-mobile.tsx    
│   └── use-toast.ts    
├── lib/
│   ├── context/
│   │   └── auth-context.tsx   # Auth context for user/session (this is imported in auth-layout.tsx)
│   │   └── index.ts
│   │   └── progress-context.tsx
│   │   └── providers.tsx      # Combines Auth, Progress, Theme providers
│   │   └── theme-context.tsx
│   └── database.types.ts    # Supabase table types (User, Problem)
│   └── supabase.ts    # Supabase client (browser + server)
│   └── utils.ts
├── node_modules/
├── middelware.ts
├── public/
├── styles/
│   └── global.css
├── .env.local  #(Supabase URL, keys)
├── .gitignore
├── package-lock.json
├── package.json
├── postcss.config.mjs
├── tailwind.config.ts
├── tsconfig.json
└── pnpm-lock.yaml
   

supabase : 
mail = unokhan99@gmail.com
password = SdeH!re123


to add to questions.json : 
# add fields: companies, metadata tags, topic category,sub-topics, prerequisites, common mistakes, interview frequency 
expected time to solve, mastery indicators(solve time threshold,code quality patterns), optimization awareness


DB password :
SdeH!re123

Organization:
Sentiantal

Project Name:
SDEHire

project URL : https://fbjzneyzqmemdytyutht.supabase.co
anon public key : eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZianpuZXl6cW1lbWR5dHl1dGh0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTA0Mjg2MzUsImV4cCI6MjA2NjAwNDYzNX0.cqKGgI_LcL5MZ1Jza8gh_PpIHiYw0qChj0beRowxDkc



This summary distills our work together, our flow, and the objectives, ensuring clarity for continuing the integration.

---

## Project Overview

### Briefing
- **Project Name**: SDE Hire
- **Purpose**: A web application for practicing Data Structures and Algorithms (DSA) problems, aimed at preparing users for software engineering interviews.
- **Core Features**:
  - User authentication (signup, login, logout, email verification).
  - DSA problem practice with code execution via Judge0.
  - Progress tracking (solved/attempted problems, streak, stats).
  - Dashboard for user stats and problem navigation.
  - Protected routes requiring authentication.
- **Tech Stack**:
  - **Framework**: Next.js (App Router, TypeScript, React).
  - **Database/Auth**: Supabase (PostgreSQL for data, Supabase Auth for authentication).
  - **UI**: Shadcn UI components, Tailwind CSS.
  - **State Management**: React Context API (`AuthProvider`, `ProgressProvider`, `ThemeProvider`).
  - **Code Execution**: Judge0 API for running user-submitted code.
- **Current Status**:
  - Authentication is fully functional (signup, login, logout, email verification).
  - Progress tracking uses localStorage and `questions.json`.
  - Supabase PostgreSQL setup is in progress (Steps 1–3 completed).
- **Objectives**:
  1. Replace localStorage with Supabase PostgreSQL for progress tracking.
  2. Migrate `questions.json` to a `problems` table in Supabase.
  3. Ensure secure data access with Row-Level Security (RLS).
  4. Integrate database operations into the codebase (e.g., `progress-context.tsx`, `auth-context.tsx`).
  5. Maintain existing UI functionality (dashboard, problems page) with database-driven data.

### Project Structure
Based on the provided files and tree structure, here’s the relevant project structure:
sde-hire/
├── .next/
│   ├── cache/
│   │             
│   ├── server/             
│   ├── static/                  
│   ├── types/               
│   └── ...                   # Other files
├── app/
│   ├── api/
│   │   └── /route.js         # This file is a Next.js API route that executes user-submitted code and tests it against multiple inputs using the Judge0 API.
│   ├── dashboard/             # includes component folder and page.tsx file (for the main dashboard)
│   ├── dsa-tutor/             # includes component folder and page.tsx file(i am showing the whole folder structure because important)
│   │   └── components/
│   |   │   └── ai-assistance.tsx
│   |   │   └── challenge-description.tsx
│   |   │   └── code-actions.tsx
│   |   │   └── code-assistance.tsx
│   |   │   └── code-editor-section.tsx
│   |   │   └── output-section.tsx
│   |   │   └── problem-assistance.tsx
│   |   │   └── problem-header.tsx
│   │   └── dsa-tutor.css
│   │   └── languages.ts
│   │   └── page.tsx
│   │   └── questions.json     # Static DSA problem data
│   │   └── types.ts           # Types for Question, ProblemAssistance, ExecutionResult
│   ├── login/                 # includes component folder and page.tsx file
│   ├── problems/              # includes component folder and page.tsx file
│   ├── profile/               # includes component folder and page.tsx file
│   ├── signup/                # includes component folder and page.tsx file
│   ├── login/                 # includes component folder and page.tsx file
│   └── global.css             #css file
│   └── layout.tsx            #root layout file
│   └── page.tsx              #page file
├── backend/
│   └── app/                  #includes some files not that important              
│   └── explantation-server.js        #includes code for explanation server code which sends SSE to frontend components in dsa-tutor   
│   └── gen-code-server.js            #includes code for explanation server code which sends SSE to frontend components in dsa-tutor 
│   └── problem-assistance-server.js   #includes code for explanation server code which sends SSE to frontend components in dsa-tutor   
│   └── README.md
│   └── package.json
├── components/
│   └── layout /     
│   │   └── auth-layout.tsx    #this is used in almost all components as a wrapper(but the user can signin or login with any email and password as of now)
|   |
│   └── ui/          #these are ui components like accordian and stuff
|   |
│   └── theme-provider.tsx
│   └── theme-toggle.tsx
├── hooks/
│   └── use-mobile.tsx    
│   └── use-toast.ts    
├── lib/
│   ├── context/
│   │   └── auth-context.tsx   # Auth context for user/session (this is imported in auth-layout.tsx)
│   │   └── index.ts
│   │   └── progress-context.tsx
│   │   └── providers.tsx      # Combines Auth, Progress, Theme providers
│   │   └── theme-context.tsx
│   └── database.types.ts    # Supabase table types (User, Problem)
│   └── supabase.ts    # Supabase client (browser + server)
│   └── utils.ts
├── node_modules/
├── public/
├── styles/
│   └── global.css
├── .env.local  #(Supabase URL, keys)
├── .gitignore
├── package-lock.json
├── package.json
├── package.jsonnext.config.mjs
├── tailwind.config.ts
├── tsconfig.json
└── pnpm-lock.yaml

### Authentication
- **Implementation**: Uses Supabase Auth via `@supabase/ssr`.
- **Files**:
  - `lib/supabase.ts`: Defines `supabase` (browser client) and `supabaseServer` (server client with `SUPABASE_SERVICE_ROLE_KEY`).
  - `lib/context/auth-context.tsx`: Manages user state (`user`, `session`, `loading`) and auth actions (`login`, `signup`, `logout`, `resetPassword`).
  - `app/signup/signup-form.tsx`: Handles signup, passing `first_name`, `last_name`, `display_name` to `raw_user_meta_data`.
  - `app/login/login-form.tsx`: Handles login with email/password and “Remember me” option.
  - `components/layout/auth-layout.tsx`: Protects routes, displays user email in a dropdown.
- **Status**:
  - Signup creates `auth.users` entries with `raw_user_meta_data`.
  - Login sets session in `auth-context.tsx`.
  - Logout clears session.
  - Email verification is enabled (users see “Check Your Email” after signup).

### State Management
- **Providers**: Managed via React Context API in `lib/context/providers.tsx`.
  - **AuthProvider**: Wraps app, provides `user`, `session`, `login`, `signup`, etc.
  - **ProgressProvider**: Manages progress state (`problemsProgress`, `totalSolved`, `totalAttempted`, `streak`).
  - **ThemeProvider**: Handles theming (not provided, assumed to manage light/dark mode).
- **Usage**:
  - `app/layout.tsx`: Wraps the app with `AppProviders` (Theme → Auth → Progress).
  - `useAuth` and `useProgress` hooks used in components (e.g., `dashboard`, `problems`, `problem-card`).

### Progress Tracking
- **Current Implementation** (`progress-context.tsx`):
  - **State**: `ProgressState` with `problemsProgress` (record of problem statuses), `totalSolved`, `totalAttempted`, `streak`, `lastActive`.
  - **Storage**: localStorage (`problemsProgress` key).
  - **Actions**:
    - `INIT_PROGRESS`: Loads stored progress.
    - `MARK_SOLVED`: Marks a problem as solved, updates stats.
    - `MARK_ATTEMPTED`: Marks a problem as attempted.
    - `RESET_PROGRESS`: Clears progress.
    - `UPDATE_STREAK`: Manages daily streak.
  - **Functions**:
    - `markProblemSolved`, `markProblemAttempted`, `resetProgress`: Dispatch actions.
    - `getProblemStatus`: Returns problem status (`unsolved`, `solved`, `attempted`).
    - `getProgressByDifficulty`: Counts solved/total problems by difficulty using `questions.json`.
- **Usage**:
  - `stats-section.tsx`: Displays `totalSolved`, `streak`.
  - `problem-card.tsx`: Shows problem status (`Solved`, `Attempted`) via `getProblemStatus`.
  - `problems/page.tsx`: Lists problems, uses `questions.json` for data.

### Database Setup
- **Provider**: Supabase PostgreSQL with Supabase Auth.
- **Clients** (`lib/supabase.ts`):
  - `supabase`: Browser client (`createBrowserClient`) for auth (signup, login).
  - `supabaseServer`: Server client (`createClient`) with `SUPABASE_SERVICE_ROLE_KEY` for database operations.
- **Environment Variables** (`.env.local`):
  - `NEXT_PUBLIC_SUPABASE_URL`
  - `NEXT_PUBLIC_SUPABASE_ANON_KEY`
  - `SUPABASE_SERVICE_ROLE_KEY` .
- **Tables** (created):
  - **`public.users`**:
    - Columns: `id` (UUID, FK to `auth.users`), `first_name` (text), `last_name` (text), `display_name` (text, nullable), `role` (text, default ‘user’), `progress` (JSONB, default `{}`), `created_at` (timestamptz), `updated_at` (timestamptz).
    - RLS: Users read/update their own row (`auth.uid() = id`); admins manage all rows.
  - **`public.problems`**:
    - Columns: `id` (serial, PK), `title` (text), `description` (text), `difficulty` (enum: ‘Easy’, ‘Medium’, ‘Hard’), `test_cases` (JSONB), `solution` (text, nullable), `hint` (text, nullable), `tags` (text[]), `created_at` (timestamptz), `updated_at` (timestamptz).
    - RLS: Readable by all; writable by admins.
  - **Enum**: `difficulty` (‘Easy’, ‘Medium’, ‘Hard’).
- **Triggers** (Step 2):
  - `on_auth_user_created`: Runs `handle_new_user` to insert `users` row after signup, populating `first_name`, `last_name`, `display_name` from `raw_user_meta_data`.
  - `update_users_updated_at`: Updates `users.updated_at` on row changes.
- **Types** (`lib/database.types.ts`):
  - `Difficulty`: `‘Easy’ | ‘Medium’ | ‘Hard’`.
  - `Problem`: Matches `problems` table schema.
  - `User`: Matches `users` table schema, with `progress` mirroring `ProgressState`.

### Steps Completed (Supabase Integration)
Here’s a detailed recap of Steps 1–3, completed before Step 4:

#### Step 1: Set Up Supabase Server-Side Client and Add Service Role Key
- **Objective**: Enable server-side database operations.
- **Actions**:
  - Added `SUPABASE_SERVICE_ROLE_KEY` to `.env.local`.
  - Updated `lib/supabase.ts` to include `supabaseServer` (server-side client) alongside `supabase` (browser client).
  - Created `app/api/test-supabase/route.ts` to test `supabaseServer` (returned `{ message: 'Supabase server client working', data: [...] }`).
  - Deleted `test-supabase/route.ts` after confirmation.
- **Outcome**: Server-side client functional, ready for database queries.

#### Step 2: Create Database Tables, Enum, RLS Policies, and Trigger
- **Objective**: Set up Supabase PostgreSQL schema.
- **Actions**:
  - Dropped existing `users` table (confirmed okay).
  - Ran SQL in Supabase SQL Editor to:
    - Create `difficulty` enum.
    - Create `problems` table.
    - Create `users` table with `progress` (JSONB).
    - Enable RLS on both tables with policies.
    - Set up `handle_new_user` trigger for auto-inserting `users` rows.
    - Set up `update_users_updated_at` trigger.
  - Created `lib/database.types.ts` with `User`, `Problem`, `Difficulty` types.
- **Outcome**: Tables, enum, RLS, and triggers created successfully.

#### Step 3: Test Auto-Insert Users on Signup
- **Objective**: Verify `handle_new_user` trigger populates `users` table.
- **Actions**:
  - Tested signup via `app/signup/signup-form.tsx` with test user (e.g., `alice.test@example.com`).
  - Updated `signup-form.tsx` to include `display_name: ${firstName} ${lastName}` in `raw_user_meta_data`.
  - Verified `public.users` row created with:
    - `id` (UUID from `auth.users`).
    - `first_name`, `last_name`, `display_name` (e.g., “Alice Smith”).
    - `role`: “user”.
    - `progress`: `{}`.
    - `created_at`, `updated_at` timestamps.
  - Checked `auth.users` for `raw_user_meta_data` (`first_name`, `last_name`, `display_name`).
- **Outcome**: Trigger works, `users` table populates correctly on signup.

### Flow and Objectives
- **Flow**:
  - We’re integrating Supabase PostgreSQL step-by-step to replace localStorage and `questions.json`.
  - Step 1 set up the server-side client.
  - Step 2 created the database schema.
  - Step 3 ensured signup populates `users`.

TODO
  - Step 4  integrates `users.progress` for progress tracking.
  - Future steps will migrate `questions.json` to `problems` and update related components.
- **Objectives**:
  -  Migrate `questions.json` to `problems` table, update `problems/page.tsx` and `getProgressByDifficulty` to use Supabase.
  -  Ensure all features (dashboard, problems, code execution) work with Supabase, maintain security (RLS), and optimize performance.
- **Approach we must follow**:
  - Step-by-step, with one step at a time, waiting for confirmation from my side.
  - Providing artifacts for code changes.
  - Testing each step 
  - Debugging issues as they arise  

### Current State 
- **Completed**:
  - Authentication fully functional.
  - Database schema and triggers set up.
  - Signup populates `users` with `display_name`.
 

This summary captures all necessary details about the project, our progress, and the context needed to proceed. I’ve addressed the project’s structure, auth, state, progress, database, and our completed steps (1–3). For now the next step is, integrating the users table into the codebase for progress tracking, specifically updating progress-context.tsx to store and fetch progress from public.users.progress (JSONB) instead of localStorage.  I have also attached some important files from the codebase for your reference (in their current state)


------------------------------

This is the current distilled knowledge of all we have done , our project structure and all, take it in digest it , and just reply you got it breifly (in less than 50 words ) and the list of what files do you need. then we can start our work .


----------------------------------------------------------------------
***********************************************************************
***********************************************************************

/*

//this code was used for localstorage based progress tracking- kuwais 
"use client"

import type React from "react"
import { createContext, useContext, useReducer, useEffect } from "react"
import type { Question } from "@/app/dsa-tutor/types"

// Define types
type ProblemStatus = "unsolved" | "solved" | "attempted"

type ProblemProgress = {
  id: number
  status: ProblemStatus
  lastAttempted?: string
  completedAt?: string
  attempts: number
}

type ProgressState = {
  problemsProgress: Record<number, ProblemProgress>
  totalSolved: number
  totalAttempted: number
  streak: number
  lastActive?: string
}

type ProgressAction =
  | { type: "INIT_PROGRESS"; payload: ProgressState }
  | { type: "MARK_SOLVED"; payload: { problemId: number } }
  | { type: "MARK_ATTEMPTED"; payload: { problemId: number } }
  | { type: "RESET_PROGRESS" }
  | { type: "UPDATE_STREAK" }

type ProgressContextType = {
  state: ProgressState
  markProblemSolved: (problemId: number) => void
  markProblemAttempted: (problemId: number) => void
  resetProgress: () => void
  getProblemStatus: (problemId: number) => ProblemStatus
  getProgressByDifficulty: (difficulty: string) => { solved: number; total: number }
}

// Initial state
const initialState: ProgressState = {
  problemsProgress: {},
  totalSolved: 0,
  totalAttempted: 0,
  streak: 0,
}

// Create context
const ProgressContext = createContext<ProgressContextType | undefined>(undefined)

// Reducer function
function progressReducer(state: ProgressState, action: ProgressAction): ProgressState {
  switch (action.type) {
    case "INIT_PROGRESS":
      return action.payload

    case "MARK_SOLVED": {
      const { problemId } = action.payload
      const existingProgress = state.problemsProgress[problemId]

      // Only count as newly solved if it wasn't already solved
      const isNewlySolved = !existingProgress || existingProgress.status !== "solved"

      return {
        ...state,
        problemsProgress: {
          ...state.problemsProgress,
          [problemId]: {
            id: problemId,
            status: "solved",
            attempts: existingProgress ? existingProgress.attempts + 1 : 1,
            lastAttempted: new Date().toISOString(),
            completedAt: new Date().toISOString(),
          },
        },
        totalSolved: isNewlySolved ? state.totalSolved + 1 : state.totalSolved,
        totalAttempted: existingProgress ? state.totalAttempted : state.totalAttempted + 1,
        lastActive: new Date().toISOString(),
      }
    }

    case "MARK_ATTEMPTED": {
      const { problemId } = action.payload
      const existingProgress = state.problemsProgress[problemId]

      // Only increment totalAttempted if this is the first attempt
      const isFirstAttempt = !existingProgress

      return {
        ...state,
        problemsProgress: {
          ...state.problemsProgress,
          [problemId]: {
            id: problemId,
            status: existingProgress?.status === "solved" ? "solved" : "attempted",
            attempts: existingProgress ? existingProgress.attempts + 1 : 1,
            lastAttempted: new Date().toISOString(),
            completedAt: existingProgress?.completedAt,
          },
        },
        totalAttempted: isFirstAttempt ? state.totalAttempted + 1 : state.totalAttempted,
        lastActive: new Date().toISOString(),
      }
    }

    case "UPDATE_STREAK": {
      // Check if user was active today
      const today = new Date().toDateString()
      const lastActiveDate = state.lastActive ? new Date(state.lastActive).toDateString() : null

      // If active today, streak continues
      if (lastActiveDate === today) {
        return state
      }

      // If active yesterday, increment streak
      const yesterday = new Date()
      yesterday.setDate(yesterday.getDate() - 1)
      const yesterdayString = yesterday.toDateString()

      if (lastActiveDate === yesterdayString) {
        return {
          ...state,
          streak: state.streak + 1,
        }
      }

      // If not active yesterday or today, reset streak
      return {
        ...state,
        streak: 0,
      }
    }

    case "RESET_PROGRESS":
      return initialState

    default:
      return state
  }
}

// Provider component
export function ProgressProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(progressReducer, initialState)

  // Load progress from localStorage on mount
  useEffect(() => {
    const storedProgress = localStorage.getItem("problemsProgress")
    if (storedProgress) {
      try {
        const parsedProgress = JSON.parse(storedProgress)
        dispatch({ type: "INIT_PROGRESS", payload: parsedProgress })
      } catch (error) {
        console.error("Failed to parse stored progress:", error)
      }
    }

    // Update streak daily
    dispatch({ type: "UPDATE_STREAK" })

    // Set up daily streak check
    const intervalId = setInterval(
      () => {
        dispatch({ type: "UPDATE_STREAK" })
      },
      1000 * 60 * 60,
    ) // Check every hour

    return () => clearInterval(intervalId)
  }, [])

  // Save progress to localStorage whenever it changes
  useEffect(() => {
    localStorage.setItem("problemsProgress", JSON.stringify(state))
  }, [state])

  // Mark a problem as solved
  const markProblemSolved = (problemId: number) => {
    dispatch({ type: "MARK_SOLVED", payload: { problemId } })
  }

  // Mark a problem as attempted
  const markProblemAttempted = (problemId: number) => {
    dispatch({ type: "MARK_ATTEMPTED", payload: { problemId } })
  }

  // Reset all progress
  const resetProgress = () => {
    dispatch({ type: "RESET_PROGRESS" })
  }

  // Get the status of a specific problem
  const getProblemStatus = (problemId: number): ProblemStatus => {
    return state.problemsProgress[problemId]?.status || "unsolved"
  }

  // Get progress statistics by difficulty
  const getProgressByDifficulty = (difficulty: string) => {
    // This would typically fetch problems from an API or context
    // For now, we'll import from the questions.json directly
    const questions = require("@/app/dsa-tutor/questions.json") as Question[]

    const problemsByDifficulty = questions.filter((q) => q.difficulty.toLowerCase() === difficulty.toLowerCase())

    const solvedCount = problemsByDifficulty.filter((q) => state.problemsProgress[q.id]?.status === "solved").length

    return {
      solved: solvedCount,
      total: problemsByDifficulty.length,
    }
  }

  return (
    <ProgressContext.Provider
      value={{
        state,
        markProblemSolved,
        markProblemAttempted,
        resetProgress,
        getProblemStatus,
        getProgressByDifficulty,
      }}
    >
      {children}
    </ProgressContext.Provider>
  )
}

// Custom hook to use the progress context
export function useProgress() {
  const context = useContext(ProgressContext)
  if (context === undefined) {
    throw new Error("useProgress must be used within a ProgressProvider")
  }
  return context
}
 */